# 체크포인트 1-2: 기술 스택 선정 작업 계획서

## 문서 목적
개발 단계 계획서의 방향(ASGI, 비동기 큐, Whisper 기반)을 실행 관점에서 구체화하고, 환경/버전/프로세스/배포 표준을 확정한다.

## ✅ 실행 체크리스트 (MVP 우선)
- **백엔드/작업 큐**
  - [x] requirements 설치 및 버전 핀닝 확인
  - [x] .env 준비(REDIS_URL, CORS_ORIGINS, UVICORN_PORT)
  - [x] Redis 기동 및 `redis-cli ping` = PONG 확인
  - [x] Celery 워커 실행: `-P solo`(Windows)
  - [x] Uvicorn 실행 및 `/docs` 접근
  - [x] 워커 태스크 로드 확인(`[tasks] ... transcribe_video_async`)

- **API 엔드포인트**
  - [x] POST `/upload` (multipart, 필드명 `file`)
  - [x] POST `/transcribe-async` (task_id 반환)
  - [x] GET `/status/{task_id}` (상태/진행률/결과)
  - [x] 정적 제공 `/outputs/*`, `/uploads/*`

- **프런트엔드**
  - [x] Vite 프록시 8000 설정(`/api` → `http://localhost:8000`)
  - [x] Pinia store 연결(startTranscription, 상태 폴링)
  - [x] 업로드/언어 선택 UI 동작
  - [x] 결과 페이지에서 TXT/SRT 다운로드 동작

- **실시간(선택)**
  - [ ] WebSocket `/ws/progress/{task_id}` 서버 구현
  - [ ] 클라이언트 WebSocket 연결/재연결 처리

- **배포/운영**
  - [ ] docker-compose 초안(web, celery, redis)
  - [ ] 로깅 레벨/에러 응답 표준화
  - [ ] README/실행 가이드 업데이트

## 선정 결과 요약(결론)
- 백엔드: FastAPI(+Uvicorn, ASGI)
- 작업 큐: Celery + Redis
- 미디어 처리: FFmpeg(오디오 추출) + OpenAI Whisper(ASR)
- 프론트엔드: Vue 3 + Vite + Pinia + Tailwind
- 저장소: 로컬 디스크(uploads/outputs) → 추후 S3 확장
- 메타데이터(DB): MVP 생략(파일 경로/결과만), 차기 PostgreSQL

## 버전/핀닝 정책
- Python(requirements.txt)
  - fastapi==0.111.0, pydantic==2.5.3, starlette==0.37.2
  - uvicorn[standard]==0.30.0, python-multipart==0.0.9
  - celery==5.3.6, redis==5.0.1, ffmpeg-python==0.2.0, python-dotenv==1.0.1
  - openai-whisper (GPU 없으면 fp16=False)
- Node(frontend/package.json)
  - vue ^3.4.21, pinia ^2.1.7, axios ^1.6.7
  - vite ^5.2.8, @vitejs/plugin-vue ^5.0.4, Tailwind(CDN 또는 정식 설정)

## 아키텍처/프로세스
- 단일 호스트(개발):
  - Uvicorn(:8000) ← FastAPI API/정적(outputs/uploads)
  - Celery Worker ← Whisper/FFmpeg CPU 바운드 처리
  - Redis ← 브로커/결과 백엔드(Docker redis:alpine 권장)
  - Vite(:5173) ← 프록시로 백엔드 연결(/api → :8000)
- Windows 주의: Celery는 `-P solo` 권장(prefork 이슈 회피)

## 디렉토리 구조(요지)
- backend/: main.py, celery_app.py, tasks/*, utils/*, uploads/, outputs/
- frontend/: src/*, vite.config.js, package.json
- 요구사항/계획서: 요구사항_정의/, 기술_스택_선정/

## 환경 변수(.env 초안)
REDIS_URL=redis://localhost:6379/0
CORS_ORIGINS=http://localhost:5173
UVICORN_PORT=8000

## 실행 표준(개발)
- 순서: Redis → Celery → Uvicorn → Vite
- 명령:
  1) Docker Redis: `docker run -d -p 6379:6379 --name redis redis:alpine`
  2) Celery: `cd backend && celery -A celery_app.celery_app worker -P solo -l info`
  3) API: `uvicorn main:app --reload --port 8000`
  4) FE: `cd frontend && npm install && npm run dev`

## API 규약(요지)
- 업로드: POST /upload (multipart, 필드명 `file`)
- 동기 전사: POST /transcribe (짧은 파일/테스트용)
- 비동기 전사: POST /transcribe-async → task_id 반환
- 상태: GET /status/{task_id}
- 정적: /uploads/*, /outputs/*
- (선택) 실시간: WebSocket /ws/progress/{task_id}

## 보안/신뢰성
- 검증: 확장자 화이트리스트, 500MB 제한, 임시파일 정리
- CORS: 개발 `http://localhost:5173`(또는 *), 운영 제한 오리진
- 비밀정보: .env로 분리, 레포 제외
- 에러/재시도: 표준 에러 응답, Celery 재시도는 차기 반영

## 관측성/운영(초안)
- 로깅: Uvicorn info, Celery 로그, FFmpeg 예외 캡처
- 지표/알림: 차기(처리시간, 실패율, Slack)

## 성능/확장
- 모델: base 기본, tiny(속도) / medium~large(GPU)
- 수평 확장: 워커 프로세스 추가(운영 Linux 권장)
- 캐싱/해시 스킵, S3 Direct Upload/청크 업로드는 차기

## 배포 전략(초안)
- docker-compose: web(uvicorn), celery(worker), redis, (opt) frontend
- 볼륨: uploads/, outputs/
- 클라우드: EC2+S3 또는 컨테이너 서비스(ECS/EKS)

## 프런트 연동 포인트
- 프록시: Vite `/api` → http://localhost:8000
- 요청필드: `file`, `language`
- 상태: 기본 폴링(2s), WebSocket은 옵션
- 다운로드: 백엔드 정적 경로 사용

## 체크리스트
- [ ] 패키지 버전 핀닝 확인(개발/배포 동일)
- [ ] Windows Celery `-P solo` 가이드 명시
- [ ] .env 샘플/README 반영
- [ ] API 스펙 ↔ 프런트 필드명 일치 확인(`file`)
- [ ] docker-compose 초안 준비(차기)

## 수용 기준(AC)
- 문서의 버전/명령/경로가 실제 레포와 일치
- Redis/Celery/Uvicorn/Vite를 문서 그대로 기동 가능
- 업로드→비동기 전사→상태→다운로드 경로 동작 확인

