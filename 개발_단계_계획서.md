# ë™ì˜ìƒ í…ìŠ¤íŠ¸ ì „ì‚¬ í”„ë¡œì íŠ¸ ê°œë°œ ê³„íšì„œ

## ğŸ“‹ í”„ë¡œì íŠ¸ ê°œìš”
ë™ì˜ìƒì—ì„œ ìŒì„±ì„ ì¶”ì¶œí•˜ê³  í…ìŠ¤íŠ¸ë¡œ ë³€í™˜í•˜ëŠ” ìë™ ì „ì‚¬ ì‹œìŠ¤í…œ êµ¬ì¶•

---

## âœ… ì§„í–‰ ì²´í¬ë¦¬ìŠ¤íŠ¸ (ìš”ì•½)
- **Phase 1**
  - [x] 1-1 ìš”êµ¬ì‚¬í•­ ì •ì˜ ì™„ë£Œ (ì „ìš© ë¬¸ì„œ ì‘ì„±)
  - [x] 1-2 ê¸°ìˆ  ìŠ¤íƒ ì„ íƒ ì™„ë£Œ (ì „ìš© ë¬¸ì„œ ì‘ì„±)
- **Phase 2**
  - [x] 2-1 ê¸°ë³¸ í™˜ê²½ êµ¬ì¶• (venv/íŒ¨í‚¤ì§€/ì„¤ì •)
  - [x] 2-2 FFmpeg ì„¤ì¹˜ ë° ê²½ë¡œ ì„¤ì • í™•ì¸
  - [x] 2-3 í”„ë¡œì íŠ¸ êµ¬ì¡° ìƒì„±
- **Phase 3**
  - [x] 3-1 ì—…ë¡œë“œ/ê²€ì¦ API êµ¬í˜„
  - [x] 3-2 ì˜¤ë””ì˜¤ ì¶”ì¶œ ê¸°ëŠ¥ êµ¬í˜„
  - [x] 3-3 Whisper í†µí•© ë° ë™ê¸° ì „ì‚¬ êµ¬í˜„
  - [x] 3-4 Celery/Redis ë¹„ë™ê¸° íŒŒì´í”„ë¼ì¸ êµ¬í˜„
  - [ ] 3-5 WebSocket ì‹¤ì‹œê°„ ì§„í–‰ë¥  (ì„ íƒ)
- **Phase 4**
  - [x] 4-1 Vue 3 í”„ëŸ°íŠ¸ êµ¬ì¶• (Vite/Pinia/Tailwind)
  - [x] 4-2 Pinia ìŠ¤í† ì–´/ìƒíƒœ í´ë§ êµ¬í˜„
  - [x] 4-3 ì—…ë¡œë“œ/ì§„í–‰/ê²°ê³¼ UI êµ¬í˜„
  - [x] 4-4 ì¶”ê°€ ê¸°ëŠ¥(íˆìŠ¤í† ë¦¬ ë“±) ë° ìµœì í™”
- **Phase 5 ~ 7**
  - [x] 5-1 ì„±ëŠ¥ ìµœì í™” (beam/best_of/GPU ë“±)
  - [ ] 5-2 ì¶”ê°€ ê¸°ëŠ¥ (ë‹¤êµ­ì–´ ìë™ ê°ì§€/í™”ìë¶„ë¦¬ ë“±)
  - [ ] 6-1 ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ / 6-2 í†µí•© í…ŒìŠ¤íŠ¸
  - [ ] 7-1 Docker ë°°í¬ / 7-2 í´ë¼ìš°ë“œ ë°°í¬

## ğŸš€ ìš”ì•½ ê²°ë¡ : FastAPI(+Uvicorn, ASGI) + Celery/Redis ê¶Œì¥
- **ìë™ ë¬¸ì„œí™” & ìŠ¤í‚¤ë§ˆ ê²€ì¦**: íƒ€ì…íŒíŠ¸ ê¸°ë°˜ OpenAPI(Swagger/Redoc) ìë™ ìƒì„±ìœ¼ë¡œ í”„ëŸ°íŠ¸ í˜‘ì—…ê³¼ í…ŒìŠ¤íŠ¸ê°€ ìˆ˜ì›”í•©ë‹ˆë‹¤.
- **ì‹¤ì‹œê°„/ë™ì‹œì„±ì— ìœ ë¦¬(ASGI)**: WebSocket ë“± ì‹¤ì‹œê°„ ì§„í–‰ë¥  í‘¸ì‹œê°€ ê°„ë‹¨í•˜ë©° ì¥ì‹œê°„ ì—°ê²°/ìŠ¤íŠ¸ë¦¬ë°ì— ê°•í•©ë‹ˆë‹¤.
- **ëŒ€ìš©ëŸ‰ ì—…ë¡œë“œÂ·IO ì¹œí™”**: ì—…ë¡œë“œâ†’ë¹„ë™ê¸° ì²˜ë¦¬â†’ìƒíƒœ ì¡°íšŒ íŒ¨í„´ì— ì í•©í•˜ë©° CPU ë°”ìš´ë“œ(ffmpeg/ASR)ëŠ” Celeryë¡œ ì˜¤í”„ë¡œë”©í•©ë‹ˆë‹¤.
- **ë°°í¬/í…ŒìŠ¤íŠ¸ í¸ì˜**: Uvicornìœ¼ë¡œ ë°”ë¡œ ì„œë¹„ìŠ¤ ê°€ëŠ¥í•˜ê³ , í…ŒìŠ¤íŠ¸ í´ë¼ì´ì–¸íŠ¸ë¡œ WebSocketê¹Œì§€ ë™ì¼ ë°©ì‹ìœ¼ë¡œ ê²€ì¦ ê°€ëŠ¥í•©ë‹ˆë‹¤.


## âœ… Phase 1: í”„ë¡œì íŠ¸ ì¤€ë¹„ ë° ê¸°íš

### ì²´í¬í¬ì¸íŠ¸ 1-1: ìš”êµ¬ì‚¬í•­ ì •ì˜
**ì‘ì—… ë‚´ìš©:**
- ì§€ì›í•  ë™ì˜ìƒ í¬ë§· ê²°ì • (MP4, AVI, MOV ë“±)
- ìµœëŒ€ íŒŒì¼ í¬ê¸° ë° ê¸¸ì´ ì œí•œ ì„¤ì •
- ì§€ì› ì–¸ì–´ ê²°ì • (í•œêµ­ì–´, ì˜ì–´, ë‹¤êµ­ì–´ ë“±)
- ì¶œë ¥ í¬ë§· ê²°ì • (TXT, SRT, VTT ë“±)
- ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤ í˜•íƒœ ê²°ì • (ì›¹ì•±, ë°ìŠ¤í¬í†±, CLI ë“±)

**ì˜ˆìƒ ì†Œìš” ì‹œê°„:** 1-2ì¼

### ì²´í¬í¬ì¸íŠ¸ 1-2: ê¸°ìˆ  ìŠ¤íƒ ì„ íƒ
**ì¶”ì²œ ê¸°ìˆ  ìŠ¤íƒ:**

**ë°±ì—”ë“œ:**
- Python (ë©”ì¸ ì–¸ì–´) - ffmpeg, ìŒì„±ì²˜ë¦¬ì— ìµœì í™”
- FastAPI (ì›¹ í”„ë ˆì„ì›Œí¬, ASGI)
- Uvicorn (ASGI ì„œë²„)
- Celery (ë¹„ë™ê¸° ì‘ì—… ì²˜ë¦¬)
- Redis (ì‘ì—… í ê´€ë¦¬)

**ìŒì„± ì¸ì‹ ì—”ì§„ ì˜µì…˜:**
1. **OpenAI Whisper** (ì¶”ì²œ)
   - ì¥ì : ë†’ì€ ì •í™•ë„, ë‹¤êµ­ì–´ ì§€ì›, ë¬´ë£Œ
   - ë‹¨ì : GPU ê¶Œì¥, ì²˜ë¦¬ ì‹œê°„ ë‹¤ì†Œ ì†Œìš”
   
2. **Google Cloud Speech-to-Text**
   - ì¥ì : ë§¤ìš° ë†’ì€ ì •í™•ë„, ì‹¤ì‹œê°„ ì²˜ë¦¬ ê°€ëŠ¥
   - ë‹¨ì : ìœ ë£Œ, API í‚¤ í•„ìš”
   
3. **Assembly AI**
   - ì¥ì : ì‚¬ìš©í•˜ê¸° ì‰¬ì›€, ë†’ì€ ì •í™•ë„
   - ë‹¨ì : ìœ ë£Œ

**í”„ë¡ íŠ¸ì—”ë“œ:**
- Vue 3 (Composition API)
- Vite (ë²ˆë“¤ëŸ¬)
- Pinia (ìƒíƒœê´€ë¦¬)
- Tailwind CSS

**ì €ì¥ì†Œ:**
- PostgreSQL (ë©”íƒ€ë°ì´í„° ì €ì¥)
- AWS S3 ë˜ëŠ” ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ (íŒŒì¼ ì €ì¥)

**ì˜ˆìƒ ì†Œìš” ì‹œê°„:** 1ì¼

---

## âœ… Phase 2: ê°œë°œ í™˜ê²½ ì„¤ì •

### ì²´í¬í¬ì¸íŠ¸ 2-1: ê¸°ë³¸ í™˜ê²½ êµ¬ì¶•
**ë‹¨ê³„ë³„ ì‹¤í–‰:**

```bash
# 1. í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ ìƒì„±
mkdir video-transcription
cd video-transcription

# 2. Python ê°€ìƒí™˜ê²½ ìƒì„±
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate

# 3. í•„ìˆ˜ íŒ¨í‚¤ì§€ ì„¤ì¹˜
pip install fastapi uvicorn[standard] python-multipart
pip install openai-whisper
pip install ffmpeg-python
pip install celery
pip install redis
pip install python-dotenv
```

**ì˜ˆìƒ ì†Œìš” ì‹œê°„:** 2ì‹œê°„

### ì²´í¬í¬ì¸íŠ¸ 2-2: FFmpeg ì„¤ì¹˜
**FFmpegëŠ” ë™ì˜ìƒì—ì„œ ì˜¤ë””ì˜¤ë¥¼ ì¶”ì¶œí•˜ëŠ” í•„ìˆ˜ ë„êµ¬ì…ë‹ˆë‹¤.**

**macOS:**
```bash
brew install ffmpeg
```

**Ubuntu/Debian:**
```bash
sudo apt update
sudo apt install ffmpeg
```

**Windows:**
- FFmpeg ê³µì‹ ì‚¬ì´íŠ¸ì—ì„œ ë‹¤ìš´ë¡œë“œ
- í™˜ê²½ ë³€ìˆ˜ PATHì— ì¶”ê°€

**ê²€ì¦:**
```bash
ffmpeg -version
```

**ì˜ˆìƒ ì†Œìš” ì‹œê°„:** 30ë¶„

### ì²´í¬í¬ì¸íŠ¸ 2-3: í”„ë¡œì íŠ¸ êµ¬ì¡° ìƒì„±
```
video-transcription/
â”œâ”€â”€ main.py                 # FastAPI ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ (Uvicorn)
â”œâ”€â”€ celery_app.py           # Celery ì„¤ì •
â”œâ”€â”€ config.py               # ì„¤ì • íŒŒì¼
â”œâ”€â”€ requirements.txt        # ì˜ì¡´ì„± ëª©ë¡
â”œâ”€â”€ .env                    # í™˜ê²½ ë³€ìˆ˜
â”œâ”€â”€ uploads/                # ì—…ë¡œë“œëœ ë™ì˜ìƒ ì„ì‹œ ì €ì¥
â”œâ”€â”€ outputs/                # ì „ì‚¬ ê²°ê³¼ ì €ì¥
â”œâ”€â”€ models/                 # Whisper ëª¨ë¸ ì €ì¥
â”œâ”€â”€ tasks/
â”‚   â”œâ”€â”€ transcription.py     # ì „ì‚¬ ì‘ì—… ë¡œì§
â”‚   â”œâ”€â”€ video_processing.py  # ë™ì˜ìƒ ì²˜ë¦¬ ë¡œì§
â”‚   â””â”€â”€ async_transcription.py # ë¹„ë™ê¸° ì „ì‚¬ íƒœìŠ¤í¬
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ file_handler.py      # íŒŒì¼ ì²˜ë¦¬ ìœ í‹¸
â”‚   â””â”€â”€ validator.py         # ì…ë ¥ ê²€ì¦
â””â”€â”€ frontend/                # Vue 3 í”„ë¡ íŠ¸ì—”ë“œ
    â”œâ”€â”€ src/
    â”‚   â”œâ”€â”€ components/      # Vue ì»´í¬ë„ŒíŠ¸
    â”‚   â”œâ”€â”€ stores/          # Pinia ìŠ¤í† ì–´
    â”‚   â”œâ”€â”€ App.vue          # ë©”ì¸ ì•±
    â”‚   â”œâ”€â”€ main.js          # ì—”íŠ¸ë¦¬í¬ì¸íŠ¸
    â”‚   â””â”€â”€ style.css        # Tailwind CSS
    â”œâ”€â”€ public/
    â”œâ”€â”€ index.html
    â”œâ”€â”€ vite.config.js       # Vite ì„¤ì •
    â””â”€â”€ package.json
```

**ì˜ˆìƒ ì†Œìš” ì‹œê°„:** 30ë¶„

---

## âœ… Phase 3: í•µì‹¬ ê¸°ëŠ¥ ê°œë°œ

### ì²´í¬í¬ì¸íŠ¸ 3-1: ë™ì˜ìƒ ì—…ë¡œë“œ ë° ê²€ì¦
**êµ¬í˜„ ë‚´ìš©:**

```python
# utils/validator.py
import os

ALLOWED_EXTENSIONS = {'mp4', 'avi', 'mov', 'mkv', 'flv', 'wmv'}
MAX_FILE_SIZE = 500 * 1024 * 1024  # 500MB

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def validate_file_size(file):
    file.seek(0, os.SEEK_END)
    file_length = file.tell()
    file.seek(0)
    return file_length <= MAX_FILE_SIZE
```

```python
# main.py (ì¼ë¶€)
from fastapi import FastAPI, UploadFile, File, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from starlette.staticfiles import StaticFiles
import os
import shutil
from utils.validator import allowed_file, validate_file_size

app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # ê°œë°œìš©
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

UPLOAD_FOLDER = "uploads"
OUTPUT_FOLDER = "outputs"
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(OUTPUT_FOLDER, exist_ok=True)

# ì •ì  íŒŒì¼ ì„œë¹™ (ë‹¤ìš´ë¡œë“œìš©)
app.mount("/uploads", StaticFiles(directory=UPLOAD_FOLDER), name="uploads")
app.mount("/outputs", StaticFiles(directory=OUTPUT_FOLDER), name="outputs")

@app.post("/upload")
async def upload_video(file: UploadFile = File(...)):
    if not file or file.filename == "":
        raise HTTPException(status_code=400, detail="íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤")
    
    if not allowed_file(file.filename):
        raise HTTPException(status_code=400, detail="ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤")

    if not validate_file_size(file.file):
        raise HTTPException(status_code=400, detail="íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤ (ìµœëŒ€ 500MB)")

    filename = os.path.basename(file.filename)
    filepath = os.path.join(UPLOAD_FOLDER, filename)

    with open(filepath, "wb") as out_file:
        shutil.copyfileobj(file.file, out_file)

    return {
        "message": "ì—…ë¡œë“œ ì„±ê³µ",
        "filename": filename,
        "filepath": f"uploads/{filename}",
    }
```

**í…ŒìŠ¤íŠ¸ ë°©ë²•:**
- Postman ë˜ëŠ” curlë¡œ íŒŒì¼ ì—…ë¡œë“œ í…ŒìŠ¤íŠ¸
- ë‹¤ì–‘í•œ íŒŒì¼ í˜•ì‹ìœ¼ë¡œ ê²€ì¦ ë¡œì§ í…ŒìŠ¤íŠ¸

**ì˜ˆìƒ ì†Œìš” ì‹œê°„:** 4ì‹œê°„

### ì²´í¬í¬ì¸íŠ¸ 3-2: ì˜¤ë””ì˜¤ ì¶”ì¶œ ê¸°ëŠ¥
**êµ¬í˜„ ë‚´ìš©:**

```python
# tasks/video_processing.py
import ffmpeg
import os

def extract_audio(video_path, output_audio_path):
    """
    ë™ì˜ìƒì—ì„œ ì˜¤ë””ì˜¤ë¥¼ ì¶”ì¶œí•˜ì—¬ WAV í˜•ì‹ìœ¼ë¡œ ì €ì¥
    """
    try:
        # FFmpegë¥¼ ì‚¬ìš©í•˜ì—¬ ì˜¤ë””ì˜¤ ì¶”ì¶œ
        stream = ffmpeg.input(video_path)
        stream = ffmpeg.output(stream, output_audio_path, 
                              acodec='pcm_s16le',  # WAV í¬ë§·
                              ac=1,                 # ëª¨ë…¸ ì±„ë„
                              ar='16000')           # 16kHz ìƒ˜í”Œë§
        ffmpeg.run(stream, overwrite_output=True, quiet=True)
        
        return True, output_audio_path
    except ffmpeg.Error as e:
        return False, f"ì˜¤ë””ì˜¤ ì¶”ì¶œ ì‹¤íŒ¨: {str(e)}"

def get_video_duration(video_path):
    """
    ë™ì˜ìƒì˜ ê¸¸ì´ë¥¼ ì´ˆ ë‹¨ìœ„ë¡œ ë°˜í™˜
    """
    try:
        probe = ffmpeg.probe(video_path)
        duration = float(probe['streams'][0]['duration'])
        return duration
    except Exception as e:
        return None
```

**í…ŒìŠ¤íŠ¸ ë°©ë²•:**
```python
# í…ŒìŠ¤íŠ¸ ì½”ë“œ
if __name__ == "__main__":
    video_path = "uploads/test_video.mp4"
    audio_path = "uploads/test_audio.wav"
    
    success, result = extract_audio(video_path, audio_path)
    if success:
        print(f"ì˜¤ë””ì˜¤ ì¶”ì¶œ ì„±ê³µ: {result}")
        duration = get_video_duration(video_path)
        print(f"ë™ì˜ìƒ ê¸¸ì´: {duration}ì´ˆ")
    else:
        print(f"ì˜¤ë””ì˜¤ ì¶”ì¶œ ì‹¤íŒ¨: {result}")
```

**ì˜ˆìƒ ì†Œìš” ì‹œê°„:** 3ì‹œê°„

### ì²´í¬í¬ì¸íŠ¸ 3-3: Whisper ëª¨ë¸ í†µí•© ë° ì „ì‚¬
**êµ¬í˜„ ë‚´ìš©:**

```python
# tasks/transcription.py
import whisper
import os
from datetime import datetime

class TranscriptionService:
    def __init__(self, model_size='base'):
        """
        model_size ì˜µì…˜: tiny, base, small, medium, large
        - tiny: ê°€ì¥ ë¹ ë¦„, ì •í™•ë„ ë‚®ìŒ
        - base: ê· í˜•ì¡íŒ ì„ íƒ (ì¶”ì²œ)
        - large: ê°€ì¥ ì •í™•, ëŠë¦¼ (GPU í•„ìš”)
        """
        print(f"Whisper ëª¨ë¸ ë¡œë”© ì¤‘... ({model_size})")
        self.model = whisper.load_model(model_size)
        print("ëª¨ë¸ ë¡œë”© ì™„ë£Œ!")
    
    def transcribe(self, audio_path, language='ko'):
        """
        ì˜¤ë””ì˜¤ íŒŒì¼ì„ í…ìŠ¤íŠ¸ë¡œ ì „ì‚¬
        
        Parameters:
        - audio_path: ì˜¤ë””ì˜¤ íŒŒì¼ ê²½ë¡œ
        - language: ì–¸ì–´ ì½”ë“œ (ko, en, ja ë“±)
        
        Returns:
        - dict: ì „ì‚¬ ê²°ê³¼
        """
        try:
            print(f"ì „ì‚¬ ì‹œì‘: {audio_path}")
            
            # Whisperë¡œ ì „ì‚¬ ìˆ˜í–‰
            result = self.model.transcribe(
                audio_path,
                language=language,
                fp16=False,  # CPU ì‚¬ìš© ì‹œ False
                verbose=True
            )
            
            return {
                'success': True,
                'text': result['text'],
                'segments': result['segments'],
                'language': result['language']
            }
        
        except Exception as e:
            return {
                'success': False,
                'error': str(e)
            }
    
    def save_transcription(self, result, output_path):
        """
        ì „ì‚¬ ê²°ê³¼ë¥¼ íŒŒì¼ë¡œ ì €ì¥
        """
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(result['text'])
            return True
        except Exception as e:
            print(f"ì €ì¥ ì‹¤íŒ¨: {e}")
            return False
    
    def create_srt(self, segments, output_path):
        """
        SRT ìë§‰ íŒŒì¼ ìƒì„±
        """
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                for i, segment in enumerate(segments, start=1):
                    start = self._format_timestamp(segment['start'])
                    end = self._format_timestamp(segment['end'])
                    text = segment['text'].strip()
                    
                    f.write(f"{i}\n")
                    f.write(f"{start} --> {end}\n")
                    f.write(f"{text}\n\n")
            
            return True
        except Exception as e:
            print(f"SRT ìƒì„± ì‹¤íŒ¨: {e}")
            return False
    
    def _format_timestamp(self, seconds):
        """
        ì´ˆë¥¼ SRT íƒ€ì„ìŠ¤íƒ¬í”„ í˜•ì‹ìœ¼ë¡œ ë³€í™˜
        """
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = int(seconds % 60)
        millis = int((seconds % 1) * 1000)
        
        return f"{hours:02d}:{minutes:02d}:{secs:02d},{millis:03d}"
```

**ì „ì²´ íŒŒì´í”„ë¼ì¸ í†µí•©:**

```python
# main.pyì— ì¶”ê°€
from fastapi import UploadFile, File, Form, HTTPException
from tasks.video_processing import extract_audio, get_video_duration
from tasks.transcription import TranscriptionService
import uuid
import os
import shutil

# ì „ì—­ ë³€ìˆ˜ë¡œ ëª¨ë¸ ì´ˆê¸°í™” (ì•± ì‹œì‘ ì‹œ í•œ ë²ˆë§Œ)
transcription_service = TranscriptionService(model_size='base')

@app.post("/transcribe")
async def transcribe_video(file: UploadFile = File(...), language: str = Form("ko")):
    if not file or file.filename == "":
        raise HTTPException(status_code=400, detail="íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤")

    job_id = str(uuid.uuid4())
    
    # íŒŒì¼ ì €ì¥
    video_filename = f"{job_id}_{os.path.basename(file.filename)}"
    video_path = os.path.join(UPLOAD_FOLDER, video_filename)
    with open(video_path, "wb") as out_file:
        shutil.copyfileobj(file.file, out_file)
    
    # ì˜¤ë””ì˜¤ ì¶”ì¶œ
    audio_path = os.path.join(UPLOAD_FOLDER, f"{job_id}.wav")
    success, result = extract_audio(video_path, audio_path)
    if not success:
        raise HTTPException(status_code=500, detail=result)
    
    # ì „ì‚¬ ìˆ˜í–‰
    transcription_result = transcription_service.transcribe(audio_path, language)
    if not transcription_result['success']:
        raise HTTPException(status_code=500, detail=transcription_result['error'])
    
    # ê²°ê³¼ ì €ì¥
    output_txt = os.path.join(OUTPUT_FOLDER, f"{job_id}.txt")
    output_srt = os.path.join(OUTPUT_FOLDER, f"{job_id}.srt")
    transcription_service.save_transcription(transcription_result, output_txt)
    transcription_service.create_srt(transcription_result['segments'], output_srt)
    
    # ì„ì‹œ íŒŒì¼ ì •ë¦¬
    os.remove(video_path)
    os.remove(audio_path)
    
    return {
        'job_id': job_id,
        'text': transcription_result['text'],
        'txt_file': f"outputs/{job_id}.txt",
        'srt_file': f"outputs/{job_id}.srt",
        'language': transcription_result['language']
    }
```

**í…ŒìŠ¤íŠ¸ ë°©ë²•:**
```bash
# curlë¡œ í…ŒìŠ¤íŠ¸
curl -X POST -F "file=@test_video.mp4" -F "language=ko" \
  http://localhost:8000/transcribe
```

**ì˜ˆìƒ ì†Œìš” ì‹œê°„:** 8ì‹œê°„

### ì²´í¬í¬ì¸íŠ¸ 3-4: ë¹„ë™ê¸° ì²˜ë¦¬ (Celery í†µí•©)
**ê¸´ ë™ì˜ìƒ ì²˜ë¦¬ë¥¼ ìœ„í•œ ë¹„ë™ê¸° ì‘ì—… í**

```python
# celery_app.py
from celery import Celery
import os

celery_app = Celery(
    'video_transcription',
    broker='redis://localhost:6379/0',
    backend='redis://localhost:6379/0'
)

celery_app.conf.update(
    task_serializer='json',
    accept_content=['json'],
    result_serializer='json',
    timezone='Asia/Seoul',
    enable_utc=True,
)
```

```python
# tasks/async_transcription.py
from celery_app import celery_app
from tasks.video_processing import extract_audio
from tasks.transcription import TranscriptionService
import os

transcription_service = TranscriptionService(model_size='base')

@celery_app.task(bind=True)
def transcribe_video_async(self, video_path, language='ko'):
    """
    ë¹„ë™ê¸°ë¡œ ë™ì˜ìƒ ì „ì‚¬ ìˆ˜í–‰
    """
    try:
        # ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
        self.update_state(state='PROGRESS', meta={'progress': 10})
        
        # ì˜¤ë””ì˜¤ ì¶”ì¶œ
        audio_path = video_path.replace('.mp4', '.wav')
        success, result = extract_audio(video_path, audio_path)
        
        if not success:
            return {'success': False, 'error': result}
        
        self.update_state(state='PROGRESS', meta={'progress': 30})
        
        # ì „ì‚¬ ìˆ˜í–‰
        transcription_result = transcription_service.transcribe(audio_path, language)
        
        self.update_state(state='PROGRESS', meta={'progress': 90})
        
        # íŒŒì¼ ì €ì¥
        job_id = os.path.basename(video_path).split('_')[0]
        output_txt = f"outputs/{job_id}.txt"
        output_srt = f"outputs/{job_id}.srt"
        
        transcription_service.save_transcription(transcription_result, output_txt)
        transcription_service.create_srt(transcription_result['segments'], output_srt)
        
        # ì„ì‹œ íŒŒì¼ ì •ë¦¬
        os.remove(video_path)
        os.remove(audio_path)
        
        return {
            'success': True,
            'job_id': job_id,
            'text': transcription_result['text'],
            'txt_file': output_txt,
            'srt_file': output_srt
        }
    
    except Exception as e:
        return {'success': False, 'error': str(e)}
```

```python
# main.py ìˆ˜ì •
from celery_app import celery_app
from tasks.async_transcription import transcribe_video_async
from fastapi import UploadFile, File, Form
import uuid
import os
import shutil

@app.post('/transcribe-async')
async def transcribe_video_async_endpoint(file: UploadFile = File(...), language: str = Form('ko')):
    job_id = str(uuid.uuid4())
    video_filename = f"{job_id}_{os.path.basename(file.filename)}"
    video_path = os.path.join(UPLOAD_FOLDER, video_filename)
    with open(video_path, "wb") as out_file:
        shutil.copyfileobj(file.file, out_file)
    
    # Celery ì‘ì—… ì‹œì‘
    task = transcribe_video_async.delay(video_path, language)
    
    return {
        'job_id': job_id,
        'task_id': task.id,
        'status': 'processing'
    }

@app.get('/status/{task_id}')
def get_task_status(task_id: str):
    task = celery_app.AsyncResult(task_id)
    
    if task.state == 'PENDING':
        return {'state': task.state, 'progress': 0}
    elif task.state == 'PROGRESS':
        info = task.info or {}
        return {'state': task.state, 'progress': info.get('progress', 0)}
    elif task.state == 'SUCCESS':
        return {'state': task.state, 'result': task.result}
    else:
        return {'state': task.state, 'error': str(task.info)}
```

**Celery Worker ì‹¤í–‰:**
```bash
# í„°ë¯¸ë„ 1: Redis ì‹œì‘
redis-server

# í„°ë¯¸ë„ 2: Celery worker ì‹œì‘
celery -A celery_app.celery_app worker --loglevel=info

# í„°ë¯¸ë„ 3: FastAPI(Uvicorn) ì•± ì‹œì‘
uvicorn main:app --reload --port 8000
```
### ì²´í¬í¬ì¸íŠ¸ 3-5: ì‹¤ì‹œê°„ ì§„í–‰ë¥  (WebSocket, ì„ íƒ)
```python
# main.py (ì„ íƒ) - WebSocket ì§„í–‰ë¥  ìŠ¤íŠ¸ë¦¬ë°
from fastapi import WebSocket
import asyncio
from celery_app import celery_app

@app.websocket("/ws/progress/{task_id}")
async def websocket_progress(websocket: WebSocket, task_id: str):
    await websocket.accept()
    try:
        while True:
            task = celery_app.AsyncResult(task_id)
            payload = {"state": task.state}
            if task.state == "PROGRESS":
                info = task.info or {}
                payload["progress"] = info.get("progress", 0)
            elif task.state == "SUCCESS":
                payload["result"] = task.result
                await websocket.send_json(payload)
                break
            elif task.state == "FAILURE":
                payload["error"] = str(task.info)
                await websocket.send_json(payload)
                break

            await websocket.send_json(payload)
            await asyncio.sleep(0.5)
    finally:
        await websocket.close()
```

**ì˜ˆìƒ ì†Œìš” ì‹œê°„:** 6ì‹œê°„

---

## âœ… Phase 4: í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œ (Vue 3 + Vite + Pinia)

### ì²´í¬í¬ì¸íŠ¸ 4-1: Vue 3 í”„ë¡œì íŠ¸ ì´ˆê¸°í™”
**Viteë¡œ Vue 3 í”„ë¡œì íŠ¸ ìƒì„±:**

```bash
# Vue 3 + Vite í”„ë¡œì íŠ¸ ìƒì„±
npm create vite@latest frontend -- --template vue
cd frontend

# í•„ìˆ˜ íŒ¨í‚¤ì§€ ì„¤ì¹˜
npm install
npm install pinia axios
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p
```

**Tailwind CSS ì„¤ì •:**

```javascript
// tailwind.config.js
export default {
  content: [
    "./index.html",
    "./src/**/*.{vue,js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
```

```css
/* src/style.css */
@tailwind base;
@tailwind components;
@tailwind utilities;
```

**Vite í”„ë¡ì‹œ ì„¤ì • (CORS í•´ê²°):**

```javascript
// vite.config.js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:8000',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  }
})
```

**ì˜ˆìƒ ì†Œìš” ì‹œê°„:** 1ì‹œê°„

### ì²´í¬í¬ì¸íŠ¸ 4-2: Pinia Store êµ¬ì„±
**ì „ì‚¬ ì‘ì—… ìƒíƒœê´€ë¦¬ë¥¼ ìœ„í•œ Store:**

```javascript
// src/stores/transcription.js
import { defineStore } from 'pinia'
import axios from 'axios'

export const useTranscriptionStore = defineStore('transcription', {
  state: () => ({
    // ì—…ë¡œë“œ ìƒíƒœ
    selectedFile: null,
    selectedLanguage: 'ko',
    
    // ì‘ì—… ìƒíƒœ
    isProcessing: false,
    currentTaskId: null,
    progress: 0,
    statusMessage: '',
    
    // ê²°ê³¼
    transcriptionResult: null,
    error: null,
    
    // ì‘ì—… íˆìŠ¤í† ë¦¬
    history: []
  }),

  getters: {
    hasResult: (state) => state.transcriptionResult !== null,
    isUploading: (state) => state.isProcessing && state.progress < 10,
    isTranscribing: (state) => state.isProcessing && state.progress >= 10,
  },

  actions: {
    // íŒŒì¼ ì„ íƒ
    setFile(file) {
      this.selectedFile = file
      this.error = null
    },

    // ì–¸ì–´ ì„¤ì •
    setLanguage(language) {
      this.selectedLanguage = language
    },

    // ì—…ë¡œë“œ ë° ì „ì‚¬ ì‹œì‘
    async startTranscription() {
      if (!this.selectedFile) {
        this.error = 'íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”'
        return
      }

      this.isProcessing = true
      this.progress = 0
      this.error = null
      this.transcriptionResult = null

      const formData = new FormData()
      formData.append('video', this.selectedFile)
      formData.append('language', this.selectedLanguage)

      try {
        // ì—…ë¡œë“œ ë° ì‘ì—… ì‹œì‘
        const response = await axios.post('/api/transcribe-async', formData, {
          headers: { 'Content-Type': 'multipart/form-data' }
        })

        this.currentTaskId = response.data.task_id
        this.statusMessage = 'ì‘ì—…ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤'
        
        // ìƒíƒœ í´ë§ ì‹œì‘
        this.pollTaskStatus()
      } catch (err) {
        this.error = err.response?.data?.error || 'ì—…ë¡œë“œ ì‹¤íŒ¨'
        this.isProcessing = false
      }
    },

    // ì‘ì—… ìƒíƒœ í´ë§
    async pollTaskStatus() {
      const pollInterval = setInterval(async () => {
        try {
          const response = await axios.get(`/api/status/${this.currentTaskId}`)
          const { state, progress, result, error } = response.data

          if (state === 'PROGRESS') {
            this.progress = progress || 0
            this.statusMessage = `ì²˜ë¦¬ ì¤‘... ${this.progress}%`
          } else if (state === 'SUCCESS') {
            clearInterval(pollInterval)
            this.progress = 100
            this.transcriptionResult = result
            this.statusMessage = 'ì „ì‚¬ ì™„ë£Œ!'
            this.isProcessing = false
            
            // íˆìŠ¤í† ë¦¬ì— ì¶”ê°€
            this.addToHistory(result)
          } else if (state === 'FAILURE') {
            clearInterval(pollInterval)
            this.error = error || 'ì „ì‚¬ ì‹¤íŒ¨'
            this.isProcessing = false
          }
        } catch (err) {
          clearInterval(pollInterval)
          this.error = 'ìƒíƒœ í™•ì¸ ì‹¤íŒ¨'
          this.isProcessing = false
        }
      }, 2000) // 2ì´ˆë§ˆë‹¤ ìƒíƒœ í™•ì¸
    },

    // íˆìŠ¤í† ë¦¬ ì¶”ê°€
    addToHistory(result) {
      this.history.unshift({
        id: result.job_id,
        filename: this.selectedFile.name,
        language: this.selectedLanguage,
        timestamp: new Date().toISOString(),
        result: result
      })
      
      // ìµœëŒ€ 10ê°œê¹Œì§€ë§Œ ì €ì¥
      if (this.history.length > 10) {
        this.history = this.history.slice(0, 10)
      }
    },

    // ì´ˆê¸°í™”
    reset() {
      this.selectedFile = null
      this.isProcessing = false
      this.currentTaskId = null
      this.progress = 0
      this.statusMessage = ''
      this.transcriptionResult = null
      this.error = null
    },

    // ë‹¤ìš´ë¡œë“œ URL ìƒì„±
    getDownloadUrl(filepath) {
      return `http://localhost:8000/${filepath}`
    }
  }
})
```

**ì˜ˆìƒ ì†Œìš” ì‹œê°„:** 2ì‹œê°„

### ì²´í¬í¬ì¸íŠ¸ 4-3: Vue ì»´í¬ë„ŒíŠ¸ êµ¬í˜„
**ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ ì„¤ì •:**

```javascript
// src/main.js
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
import './style.css'

const app = createApp(App)
const pinia = createPinia()

app.use(pinia)
app.mount('#app')
```

**ë©”ì¸ App ì»´í¬ë„ŒíŠ¸:**

```vue
<!-- src/App.vue -->
<script setup>
import FileUpload from './components/FileUpload.vue'
import TranscriptionProgress from './components/TranscriptionProgress.vue'
import TranscriptionResult from './components/TranscriptionResult.vue'
import { useTranscriptionStore } from './stores/transcription'

const store = useTranscriptionStore()
</script>

<template>
  <div class="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100">
    <div class="container mx-auto px-4 py-8">
      <!-- í—¤ë” -->
      <header class="text-center mb-12">
        <h1 class="text-4xl font-bold text-gray-800 mb-2">
          ğŸ¥ ë™ì˜ìƒ í…ìŠ¤íŠ¸ ì „ì‚¬
        </h1>
        <p class="text-gray-600">
          ë™ì˜ìƒì„ ì—…ë¡œë“œí•˜ë©´ AIê°€ ìë™ìœ¼ë¡œ ìŒì„±ì„ í…ìŠ¤íŠ¸ë¡œ ë³€í™˜í•©ë‹ˆë‹¤
        </p>
      </header>

      <!-- ë©”ì¸ ì»¨í…ì¸  -->
      <div class="max-w-4xl mx-auto">
        <!-- ì—…ë¡œë“œ ì˜ì—­ -->
        <FileUpload v-if="!store.isProcessing" />

        <!-- ì§„í–‰ ìƒíƒœ -->
        <TranscriptionProgress v-if="store.isProcessing" />

        <!-- ê²°ê³¼ í‘œì‹œ -->
        <TranscriptionResult v-if="store.hasResult && !store.isProcessing" />

        <!-- ì—ëŸ¬ ë©”ì‹œì§€ -->
        <div 
          v-if="store.error" 
          class="mt-6 bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg"
        >
          <p class="font-medium">âŒ {{ store.error }}</p>
        </div>
      </div>
    </div>
  </div>
</template>
```

**íŒŒì¼ ì—…ë¡œë“œ ì»´í¬ë„ŒíŠ¸:**

```vue
<!-- src/components/FileUpload.vue -->
<script setup>
import { ref } from 'vue'
import { useTranscriptionStore } from '../stores/transcription'

const store = useTranscriptionStore()
const fileInput = ref(null)

const languages = [
  { code: 'ko', name: 'í•œêµ­ì–´' },
  { code: 'en', name: 'ì˜ì–´' },
  { code: 'ja', name: 'ì¼ë³¸ì–´' },
  { code: 'zh', name: 'ì¤‘êµ­ì–´' },
  { code: 'es', name: 'ìŠ¤í˜ì¸ì–´' },
  { code: 'fr', name: 'í”„ë‘ìŠ¤ì–´' },
]

const handleFileChange = (event) => {
  const file = event.target.files[0]
  if (file) {
    store.setFile(file)
  }
}

const handleDragOver = (event) => {
  event.preventDefault()
}

const handleDrop = (event) => {
  event.preventDefault()
  const file = event.dataTransfer.files[0]
  if (file) {
    store.setFile(file)
  }
}

const triggerFileInput = () => {
  fileInput.value.click()
}

const startTranscription = () => {
  store.startTranscription()
}
</script>

<template>
  <div class="bg-white rounded-2xl shadow-xl p-8">
    <!-- ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì˜ì—­ -->
    <div
      @dragover="handleDragOver"
      @drop="handleDrop"
      @click="triggerFileInput"
      class="border-3 border-dashed border-gray-300 rounded-xl p-12 text-center cursor-pointer hover:border-indigo-400 hover:bg-indigo-50 transition-all duration-300"
    >
      <div class="text-6xl mb-4">ğŸ“¹</div>
      <p class="text-lg font-medium text-gray-700 mb-2">
        ë™ì˜ìƒ íŒŒì¼ì„ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì„¸ìš”
      </p>
      <p class="text-sm text-gray-500">
        MP4, AVI, MOV, MKV ë“± (ìµœëŒ€ 500MB)
      </p>
      
      <input
        ref="fileInput"
        type="file"
        accept="video/*"
        @change="handleFileChange"
        class="hidden"
      />
    </div>

    <!-- ì„ íƒëœ íŒŒì¼ ì •ë³´ -->
    <div v-if="store.selectedFile" class="mt-6 p-4 bg-indigo-50 rounded-lg">
      <div class="flex items-center justify-between">
        <div class="flex items-center space-x-3">
          <span class="text-2xl">ğŸ¬</span>
          <div>
            <p class="font-medium text-gray-800">
              {{ store.selectedFile.name }}
            </p>
            <p class="text-sm text-gray-600">
              {{ (store.selectedFile.size / 1024 / 1024).toFixed(2) }} MB
            </p>
          </div>
        </div>
        <button
          @click="store.setFile(null)"
          class="text-red-500 hover:text-red-700 font-medium"
        >
          ì œê±°
        </button>
      </div>
    </div>

    <!-- ì–¸ì–´ ì„ íƒ -->
    <div class="mt-6">
      <label class="block text-sm font-medium text-gray-700 mb-2">
        ì–¸ì–´ ì„ íƒ
      </label>
      <select
        v-model="store.selectedLanguage"
        class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
      >
        <option 
          v-for="lang in languages" 
          :key="lang.code" 
          :value="lang.code"
        >
          {{ lang.name }}
        </option>
        </select>
    </div>

    <!-- ì „ì‚¬ ì‹œì‘ ë²„íŠ¼ -->
    <button
      @click="startTranscription"
      :disabled="!store.selectedFile"
      class="w-full mt-6 bg-indigo-600 hover:bg-indigo-700 disabled:bg-gray-300 disabled:cursor-not-allowed text-white font-semibold py-4 rounded-lg transition-colors duration-200 text-lg"
    >
      {{ store.selectedFile ? 'ğŸš€ ì „ì‚¬ ì‹œì‘' : 'íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”' }}
        </button>
      </div>
</template>
```

**ì§„í–‰ ìƒíƒœ ì»´í¬ë„ŒíŠ¸:**

```vue
<!-- src/components/TranscriptionProgress.vue -->
<script setup>
import { useTranscriptionStore } from '../stores/transcription'

const store = useTranscriptionStore()
</script>

<template>
  <div class="bg-white rounded-2xl shadow-xl p-8">
    <div class="text-center mb-6">
      <div class="inline-block animate-bounce text-6xl mb-4">âš¡</div>
      <h2 class="text-2xl font-bold text-gray-800 mb-2">
        ì „ì‚¬ ì§„í–‰ ì¤‘
      </h2>
      <p class="text-gray-600">{{ store.statusMessage }}</p>
    </div>

    <!-- ì§„í–‰ë¥  ë°” -->
    <div class="w-full bg-gray-200 rounded-full h-4 mb-4 overflow-hidden">
      <div
        class="bg-gradient-to-r from-indigo-500 to-purple-600 h-4 rounded-full transition-all duration-500 ease-out"
        :style="{ width: `${store.progress}%` }"
      ></div>
    </div>

    <!-- ì§„í–‰ë¥  í¼ì„¼íŠ¸ -->
    <p class="text-center text-2xl font-bold text-indigo-600">
      {{ store.progress }}%
    </p>

    <!-- ë‹¨ê³„ í‘œì‹œ -->
    <div class="mt-8 space-y-3">
      <div 
        class="flex items-center space-x-3"
        :class="store.progress >= 10 ? 'text-green-600' : 'text-gray-400'"
      >
        <span class="text-2xl">
          {{ store.progress >= 10 ? 'âœ…' : 'â³' }}
        </span>
        <span class="font-medium">ë™ì˜ìƒ ì—…ë¡œë“œ ì™„ë£Œ</span>
      </div>
      <div 
        class="flex items-center space-x-3"
        :class="store.progress >= 30 ? 'text-green-600' : 'text-gray-400'"
      >
        <span class="text-2xl">
          {{ store.progress >= 30 ? 'âœ…' : 'â³' }}
        </span>
        <span class="font-medium">ì˜¤ë””ì˜¤ ì¶”ì¶œ ì™„ë£Œ</span>
      </div>
      <div 
        class="flex items-center space-x-3"
        :class="store.progress >= 90 ? 'text-green-600' : 'text-gray-400'"
      >
        <span class="text-2xl">
          {{ store.progress >= 90 ? 'âœ…' : 'â³' }}
        </span>
        <span class="font-medium">ìŒì„± ì¸ì‹ ì§„í–‰ ì¤‘...</span>
      </div>
    </div>

    <!-- ì·¨ì†Œ ë²„íŠ¼ (ì„ íƒì‚¬í•­) -->
    <button
      @click="store.reset()"
      class="w-full mt-8 border-2 border-gray-300 hover:border-red-500 hover:text-red-500 font-medium py-3 rounded-lg transition-colors duration-200"
    >
      ì·¨ì†Œ
    </button>
  </div>
</template>
```

**ê²°ê³¼ í‘œì‹œ ì»´í¬ë„ŒíŠ¸:**

```vue
<!-- src/components/TranscriptionResult.vue -->
<script setup>
import { ref } from 'vue'
import { useTranscriptionStore } from '../stores/transcription'

const store = useTranscriptionStore()
const copied = ref(false)

const copyToClipboard = async () => {
  try {
    await navigator.clipboard.writeText(store.transcriptionResult.text)
    copied.value = true
    setTimeout(() => copied.value = false, 2000)
  } catch (err) {
    alert('ë³µì‚¬ ì‹¤íŒ¨')
  }
}

const downloadFile = (filepath, filename) => {
  const url = store.getDownloadUrl(filepath)
  const a = document.createElement('a')
  a.href = url
  a.download = filename
  a.click()
}

const startNew = () => {
  store.reset()
}
</script>

<template>
  <div class="bg-white rounded-2xl shadow-xl p-8">
    <!-- ì„±ê³µ í—¤ë” -->
    <div class="text-center mb-8">
      <div class="inline-block text-6xl mb-4 animate-bounce">ğŸ‰</div>
      <h2 class="text-3xl font-bold text-gray-800 mb-2">
        ì „ì‚¬ ì™„ë£Œ!
      </h2>
      <p class="text-gray-600">
        {{ store.statusMessage }}
      </p>
    </div>

    <!-- ì „ì‚¬ ê²°ê³¼ í…ìŠ¤íŠ¸ -->
    <div class="mb-6">
      <div class="flex items-center justify-between mb-3">
        <label class="font-semibold text-gray-700">ì „ì‚¬ ê²°ê³¼</label>
        <button
          @click="copyToClipboard"
          class="flex items-center space-x-2 px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors"
        >
          <span>{{ copied ? 'âœ… ë³µì‚¬ë¨!' : 'ğŸ“‹ ë³µì‚¬' }}</span>
        </button>
      </div>
      
          <textarea 
        :value="store.transcriptionResult.text"
        readonly
        rows="15"
        class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent resize-none"
      ></textarea>
          </div>

    <!-- ë‹¤ìš´ë¡œë“œ ë²„íŠ¼ë“¤ -->
    <div class="grid grid-cols-2 gap-4 mb-6">
      <button
        @click="downloadFile(store.transcriptionResult.txt_file, 'transcript.txt')"
        class="flex items-center justify-center space-x-2 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 rounded-lg transition-colors"
      >
        <span>ğŸ“„</span>
        <span>TXT ë‹¤ìš´ë¡œë“œ</span>
      </button>
      
      <button
        @click="downloadFile(store.transcriptionResult.srt_file, 'subtitles.srt')"
        class="flex items-center justify-center space-x-2 bg-purple-600 hover:bg-purple-700 text-white font-semibold py-3 rounded-lg transition-colors"
      >
        <span>ğŸ¬</span>
        <span>SRT ë‹¤ìš´ë¡œë“œ</span>
      </button>
        </div>

    <!-- ìƒˆë¡œìš´ ì „ì‚¬ ì‹œì‘ -->
    <button
      @click="startNew"
      class="w-full border-2 border-indigo-600 text-indigo-600 hover:bg-indigo-50 font-semibold py-3 rounded-lg transition-colors"
    >
      â• ìƒˆë¡œìš´ ì „ì‚¬ ì‹œì‘
    </button>
    </div>
</template>
```

**ì˜ˆìƒ ì†Œìš” ì‹œê°„:** 4ì‹œê°„

### ì²´í¬í¬ì¸íŠ¸ 4-4: ì¶”ê°€ ê¸°ëŠ¥ ë° ìµœì í™”

**íˆìŠ¤í† ë¦¬ ì»´í¬ë„ŒíŠ¸ (ì„ íƒì‚¬í•­):**

```vue
<!-- src/components/TranscriptionHistory.vue -->
<script setup>
import { useTranscriptionStore } from '../stores/transcription'

const store = useTranscriptionStore()

const formatDate = (isoString) => {
  return new Date(isoString).toLocaleString('ko-KR')
}
</script>

<template>
  <div v-if="store.history.length > 0" class="mt-8 bg-white rounded-2xl shadow-xl p-8">
    <h3 class="text-xl font-bold text-gray-800 mb-4">ğŸ“š ìµœê·¼ ì „ì‚¬ ê¸°ë¡</h3>
    
    <div class="space-y-3">
      <div
        v-for="item in store.history"
        :key="item.id"
        class="p-4 border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors"
      >
        <div class="flex items-center justify-between">
          <div>
            <p class="font-medium text-gray-800">{{ item.filename }}</p>
            <p class="text-sm text-gray-500">
              {{ formatDate(item.timestamp) }} Â· {{ item.language.toUpperCase() }}
            </p>
          </div>
          <button
            @click="store.transcriptionResult = item.result"
            class="text-indigo-600 hover:text-indigo-800 font-medium"
          >
            ë³´ê¸° â†’
          </button>
        </div>
      </div>
    </div>
  </div>
</template>
```

**ê°œë°œ ì„œë²„ ì‹¤í–‰:**

```bash
# í”„ë¡ íŠ¸ì—”ë“œ (í„°ë¯¸ë„ 1)
cd frontend
npm run dev

# ë°±ì—”ë“œ (í„°ë¯¸ë„ 2)
cd ..
uvicorn main:app --reload --port 8000

# Redis (í„°ë¯¸ë„ 3)
redis-server

# Celery Worker (í„°ë¯¸ë„ 4)
celery -A celery_app.celery_app worker --loglevel=info
```

**ì˜ˆìƒ ì†Œìš” ì‹œê°„:** 2ì‹œê°„

---

### Vue 3 ì„ íƒì˜ ì¥ì  (ì´ í”„ë¡œì íŠ¸ ê¸°ì¤€)

1. **Viteì˜ ë¹ ë¥¸ HMR**: ê°œë°œ ì¤‘ ìˆ˜ì •ì‚¬í•­ì´ ì¦‰ì‹œ ë°˜ì˜ë˜ì–´ ìƒì‚°ì„± í–¥ìƒ
2. **Piniaì˜ ì§ê´€ì ì¸ ìƒíƒœê´€ë¦¬**: 
   - ì‘ì—… ìƒíƒœ(ì—…ë¡œë“œâ†’ì§„í–‰â†’ì™„ë£Œ) ì¶”ì ì´ ê°„ë‹¨
   - TypeScript íƒ€ì… ì¶”ë¡  ìë™
   - DevTools í†µí•© ìš°ìˆ˜
3. **Composition API**: ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ë¡œì§ êµ¬ì„± ìš©ì´
4. **ì‘ì€ ë²ˆë“¤ í¬ê¸°**: Vue 3 ëŸ°íƒ€ì„ì´ Reactë³´ë‹¤ ê°€ë³ê³  ë¹ ë¦„
5. **Nuxt í™•ì¥ ê°€ëŠ¥**: ì¶”í›„ SSR/SEO í•„ìš” ì‹œ ì‰½ê²Œ ë§ˆì´ê·¸ë ˆì´ì…˜

**ì˜ˆìƒ ì´ ì†Œìš” ì‹œê°„:** 9ì‹œê°„

---

## âœ… Phase 5: ìµœì í™” ë° ê³ ê¸‰ ê¸°ëŠ¥

### ì²´í¬í¬ì¸íŠ¸ 5-1: ì„±ëŠ¥ ìµœì í™”
**êµ¬í˜„ ë‚´ìš©:**

1. **ì²­í¬ ë‹¨ìœ„ ì²˜ë¦¬** (ëŒ€ìš©ëŸ‰ íŒŒì¼)
2. **GPU ê°€ì†** (ê°€ëŠ¥í•œ ê²½ìš°)
3. **ìºì‹±** (ë™ì¼ íŒŒì¼ ì¬ì²˜ë¦¬ ë°©ì§€)
4. **ì••ì¶•** (ì €ì¥ ê³µê°„ ì ˆì•½)

```python
# ìµœì í™”ëœ ì „ì‚¬ ì˜µì…˜
result = self.model.transcribe(
    audio_path,
    language=language,
    fp16=True,  # GPU ì‚¬ìš© ì‹œ Trueë¡œ ì„¤ì •
    beam_size=5,  # ì •í™•ë„ í–¥ìƒ
    best_of=5,    # ìµœìƒì˜ ê²°ê³¼ ì„ íƒ
    temperature=0.0  # ê²°ì •ë¡ ì  ì¶œë ¥
)
```

**ì˜ˆìƒ ì†Œìš” ì‹œê°„:** 4ì‹œê°„

### ì²´í¬í¬ì¸íŠ¸ 5-2: ì¶”ê°€ ê¸°ëŠ¥
1. **í™”ì ë¶„ë¦¬ (Diarization)** - pyannote.audio ì‚¬ìš©
2. **ë‹¤êµ­ì–´ ìë™ ê°ì§€**
3. **ì‹¤ì‹œê°„ í”„ë¡œê·¸ë ˆìŠ¤ ë°”**
4. **ë°°ì¹˜ ì²˜ë¦¬** (ì—¬ëŸ¬ íŒŒì¼ ë™ì‹œ ì²˜ë¦¬)
5. **í´ë¼ìš°ë“œ ìŠ¤í† ë¦¬ì§€ ì—°ë™** (S3, Google Cloud Storage)

**ì˜ˆìƒ ì†Œìš” ì‹œê°„:** 8-16ì‹œê°„

---

## âœ… Phase 6: í…ŒìŠ¤íŠ¸ ë° ë””ë²„ê¹…

### ì²´í¬í¬ì¸íŠ¸ 6-1: ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±
```python
# tests/test_transcription.py
import unittest
from tasks.transcription import TranscriptionService

class TestTranscription(unittest.TestCase):
    def setUp(self):
        self.service = TranscriptionService(model_size='tiny')
    
    def test_transcribe_korean(self):
        result = self.service.transcribe('test_audio_ko.wav', 'ko')
        self.assertTrue(result['success'])
        self.assertIsNotNone(result['text'])
    
    def test_srt_creation(self):
        # SRT ìƒì„± í…ŒìŠ¤íŠ¸
        pass

if __name__ == '__main__':
    unittest.main()
```

**ì˜ˆìƒ ì†Œìš” ì‹œê°„:** 4ì‹œê°„

### ì²´í¬í¬ì¸íŠ¸ 6-2: í†µí•© í…ŒìŠ¤íŠ¸
- ë‹¤ì–‘í•œ ë™ì˜ìƒ í¬ë§· í…ŒìŠ¤íŠ¸
- ë‹¤ì–‘í•œ ê¸¸ì´ì˜ ë™ì˜ìƒ í…ŒìŠ¤íŠ¸
- ë°°ê²½ ì†ŒìŒì´ ìˆëŠ” ë™ì˜ìƒ í…ŒìŠ¤íŠ¸
- ì—¬ëŸ¬ í™”ìê°€ ìˆëŠ” ë™ì˜ìƒ í…ŒìŠ¤íŠ¸

**ì˜ˆìƒ ì†Œìš” ì‹œê°„:** 4ì‹œê°„

---

## âœ… Phase 7: ë°°í¬

### ì²´í¬í¬ì¸íŠ¸ 7-1: Docker ì»¨í…Œì´ë„ˆí™”
```dockerfile
# Dockerfile
FROM python:3.9-slim

RUN apt-get update && apt-get install -y \
    ffmpeg \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "8000:8000"
    volumes:
      - ./uploads:/app/uploads
      - ./outputs:/app/outputs
    depends_on:
      - redis
  
  redis:
    image: redis:alpine
    ports:
      - "6379:6379"
  
  celery:
    build: .
    command: celery -A celery_app.celery_app worker --loglevel=info
    depends_on:
      - redis
```

**ì˜ˆìƒ ì†Œìš” ì‹œê°„:** 4ì‹œê°„

### ì²´í¬í¬ì¸íŠ¸ 7-2: í´ë¼ìš°ë“œ ë°°í¬
**ì˜µì…˜:**
- AWS EC2 + S3
- Google Cloud Platform
- Heroku
- DigitalOcean

**ì˜ˆìƒ ì†Œìš” ì‹œê°„:** 4-8ì‹œê°„

---

## ğŸ“Š ì „ì²´ í”„ë¡œì íŠ¸ íƒ€ì„ë¼ì¸

| Phase | ì‘ì—… ë‚´ìš© | ì˜ˆìƒ ì†Œìš” ì‹œê°„ |
|-------|----------|--------------|
| Phase 1 | í”„ë¡œì íŠ¸ ì¤€ë¹„ ë° ê¸°íš | 2-3ì¼ |
| Phase 2 | ê°œë°œ í™˜ê²½ ì„¤ì • | 3-4ì‹œê°„ |
| Phase 3 | í•µì‹¬ ê¸°ëŠ¥ ê°œë°œ | 3-4ì¼ |
| Phase 4 | í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œ (Vue 3) | 1-1.5ì¼ |
| Phase 5 | ìµœì í™” ë° ê³ ê¸‰ ê¸°ëŠ¥ | 2-3ì¼ |
| Phase 6 | í…ŒìŠ¤íŠ¸ | 1ì¼ |
| Phase 7 | ë°°í¬ | 1ì¼ |
| **ì´í•©** | | **ì•½ 2-3ì£¼** |

---

## ğŸ¯ ì£¼ìš” ê³ ë ¤ì‚¬í•­

### ë¹„ìš©
- **ë¬´ë£Œ ì˜µì…˜:** Whisper (ë¡œì»¬ ì‹¤í–‰)
- **ìœ ë£Œ ì˜µì…˜:** Google Speech-to-Text (~$0.006/15ì´ˆ), Assembly AI

### ì„±ëŠ¥
- **CPU ì „ìš©:** tiny/base ëª¨ë¸ ì‚¬ìš©
- **GPU ì‚¬ìš© ê°€ëŠ¥:** medium/large ëª¨ë¸ ì‚¬ìš©
- 1ì‹œê°„ ë™ì˜ìƒ ì²˜ë¦¬ ì‹œê°„: 5-20ë¶„ (ëª¨ë¸ í¬ê¸°ì— ë”°ë¼)

### ì •í™•ë„ ê°œì„  íŒ
1. ìŒì§ˆ ì¢‹ì€ ì˜¤ë””ì˜¤ ì‚¬ìš©
2. ë°°ê²½ ì†ŒìŒ ì œê±° ì „ì²˜ë¦¬
3. ì ì ˆí•œ ëª¨ë¸ í¬ê¸° ì„ íƒ
4. ì •í™•í•œ ì–¸ì–´ ì§€ì •

---

## ğŸ¨ Vue 3 + Vite + Piniaë¥¼ ì„ íƒí•œ ì´ìœ 

### ì´ í”„ë¡œì íŠ¸ì— ìµœì í™”ëœ ì´ìœ 

**1. Viteì˜ íƒì›”í•œ ê°œë°œ ê²½í—˜**
- âš¡ **ì´ˆê³ ì† HMR**: ì½”ë“œ ìˆ˜ì • ì‹œ ì¦‰ì‹œ ë°˜ì˜ (Reactë³´ë‹¤ 3-5ë°° ë¹ ë¦„)
- ğŸš€ **ë¹ ë¥¸ ì½œë“œ ìŠ¤íƒ€íŠ¸**: í”„ë¡œì íŠ¸ ì‹œì‘ ì‹œê°„ 1-2ì´ˆ
- ğŸ“¦ **ìµœì í™”ëœ ë²ˆë“¤ë§**: í”„ë¡œë•ì…˜ ë¹Œë“œ í¬ê¸°ê°€ ì‘ê³  ë¹ ë¦„

**2. Piniaì˜ ì§ê´€ì ì¸ ìƒíƒœê´€ë¦¬**
```javascript
// ì „ì‚¬ ìƒíƒœë¥¼ ë‹¨ìˆœí•˜ê²Œ ê´€ë¦¬
const store = useTranscriptionStore()
store.startTranscription()  // ë©”ì„œë“œ í˜¸ì¶œë§Œìœ¼ë¡œ ì‘ì—… ì‹œì‘
```
- ğŸ§© **TypeScript ìë™ íƒ€ì… ì¶”ë¡ **: ë³„ë„ íƒ€ì… ì •ì˜ ë¶ˆí•„ìš”
- ğŸ” **Vue DevTools í†µí•©**: ìƒíƒœ ë³€í™” ì‹¤ì‹œê°„ ì¶”ì 
- ğŸ“ **ê°„ê²°í•œ ë¬¸ë²•**: Redux/Context APIë³´ë‹¤ ì½”ë“œê°€ 50% ì§§ìŒ

**3. Composition APIì˜ ì¬ì‚¬ìš©ì„±**
```javascript
// ì»¤ìŠ¤í…€ Composableë¡œ ë¡œì§ ì¬ì‚¬ìš©
function useFileUpload() {
  const validateFile = (file) => { /* ... */ }
  const uploadFile = async (file) => { /* ... */ }
  return { validateFile, uploadFile }
}
```

**4. ì‘ì€ ë²ˆë“¤ í¬ê¸°ì™€ ë¹ ë¥¸ ëŸ°íƒ€ì„**
- Vue 3 ëŸ°íƒ€ì„: ~33KB (gzip)
- React + ReactDOM: ~44KB (gzip)
- ì´ˆê¸° ë¡œë”© ì†ë„ 15-20% í–¥ìƒ

**5. ì‰¬ìš´ SSR í™•ì¥ (Nuxt)**
```bash
# ì¶”í›„ SEOê°€ í•„ìš”í•˜ë‹¤ë©´
npx nuxi init  # Nuxtë¡œ ì¦‰ì‹œ ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ëŠ¥
```

### React vs Vue ë¹„êµ (ì´ í”„ë¡œì íŠ¸ ê¸°ì¤€)

| í•­ëª© | Vue 3 + Vite | React + CRA/Vite |
|-----|-------------|------------------|
| ì´ˆê¸° ì„¤ì • | â­â­â­â­â­ ë§¤ìš° ê°„ë‹¨ | â­â­â­â­ ê°„ë‹¨ |
| ìƒíƒœê´€ë¦¬ | Pinia (ê³µì‹, ë‚´ì¥) | ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ í•„ìš” |
| ê°œë°œ ì†ë„ | HMR ì´ˆê³ ì† | HMR ë¹ ë¦„ |
| ëŸ¬ë‹ ì»¤ë¸Œ | Template ì¹œìˆ™ | JSX ë¬¸ë²• ìµí˜€ì•¼ |
| ë²ˆë“¤ í¬ê¸° | ì‘ìŒ | ì•½ê°„ í¼ |
| SSR í™•ì¥ | Nuxt (ì‰¬ì›€) | Next.js (ë³´í†µ) |

**ê²°ë¡ **: 
ë‹¨ì¼ í˜ì´ì§€ ì—…ë¡œë“œ/ì§„í–‰/ê²°ê³¼ UIë¥¼ ë¹ ë¥´ê²Œ ê°œë°œí•˜ê³ , ìƒíƒœê´€ë¦¬ê°€ ì¤‘ìš”í•œ ì´ í”„ë¡œì íŠ¸ì—ëŠ” **Vue 3 + Vite + Pinia**ê°€ ìµœì ì…ë‹ˆë‹¤. ê°œë°œ ì†ë„ì™€ ìœ ì§€ë³´ìˆ˜ì„± ëª¨ë‘ ìš°ìˆ˜í•©ë‹ˆë‹¤.

---

## ğŸ“š ì¶”ê°€ í•™ìŠµ ìë£Œ

**ë°±ì—”ë“œ:**
- Whisper ê³µì‹ ë¬¸ì„œ: https://github.com/openai/whisper
- FFmpeg ê°€ì´ë“œ: https://ffmpeg.org/documentation.html
- Celery ë¬¸ì„œ: https://docs.celeryproject.org/
- FastAPI ê³µì‹ ë¬¸ì„œ: https://fastapi.tiangolo.com/

**í”„ë¡ íŠ¸ì—”ë“œ (Vue 3):**
- Vue 3 ê³µì‹ ë¬¸ì„œ: https://vuejs.org/
- Vite ê³µì‹ ê°€ì´ë“œ: https://vitejs.dev/
- Pinia ê³µì‹ ë¬¸ì„œ: https://pinia.vuejs.org/
- Tailwind CSS: https://tailwindcss.com/docs
- Composition API: https://vuejs.org/guide/extras/composition-api-faq.html

---

## ğŸš€ ë‹¤ìŒ ë‹¨ê³„
1. Phase 1ë¶€í„° ìˆœì„œëŒ€ë¡œ ì²´í¬í¬ì¸íŠ¸ ì™„ë£Œ
2. ê° ì²´í¬í¬ì¸íŠ¸ ì™„ë£Œ í›„ í…ŒìŠ¤íŠ¸
3. ë¬¸ì œ ë°œìƒ ì‹œ í•´ë‹¹ ì„¹ì…˜ ì¬ê²€í† 
4. ëª¨ë“  Phase ì™„ë£Œ í›„ ì‹¤ì œ ì‚¬ìš© ì‚¬ë¡€ë¡œ í…ŒìŠ¤íŠ¸